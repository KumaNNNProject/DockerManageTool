#!/bin/bash

##########################################################
#[FunList]
# [简述]
# 
# 执行环境: 宿主机
# 调用方式: ./  source  sh 
# 调用参数: 			 		 	  				  
#     	   [$1]:   --help 查看帮助文档		      	  
#
# 备注: 静态函数列表，使用source包含在文件头部
##########################################################
# 备注
# exit 1  : 报错退出
# exit 0  : 无错误退出
# return int  : 函数内部，只能返回整数(0-255)
#               推荐使用return来中止后续执行
##########################################################

# ----预处理--------------------------------------------#

# 加载模式(1:主动|0:被动<默认>)
Sys_LoadMode="${Sys_LoadMode:-0}"
# 调试开关
Sys_Debug="${Sys_Debug:-0}"
App_Debug="${App_Debug:-0}"
# 默认分隔符
oldIFS=$IFS
# 测试:开关(true|false)
App_testON=false
# 测试:文件名和目录名
App_testFileName=.env
App_testDirName=lib
# 测试:多条件关系(and|or)
App_testMult=and
# 是否跳转到当前脚本目录(1:是|0:否)
App_toScriptDir="0"

# ================================================== 
# 函数名称: MAP_SET_FileList
# 函数功能: 映射表:文件列表	 
# 函数参数:  
#     	 [$1]:   文件路径(${BASH_SOURCE[0]}<默认>)
#     	         ./funlist/a/bc.sh 
#     	          /funlist/a/bc.sh 
#
# 变量列表:
#               ${MAP_Index} : MAP全局索引
#               ${MAP_ID[0]} : ID(md5sum(文件路径))
#      ${MAPSET_FileList[0]} : 文件列表(数组)
#
# 返回值:  
# 		$?: 获取调用结果(调用后立即使用)
# 		    0: 执行成功 
# 		    1: 执行失败 
# 
# ================================================== 
function MAP_SET_FileList(){
	# ${BASH_SOURCE[0]}: ./funlist/a/bc.sh
	#                      funlist/a/bc.sh
	# dirname ${BASH_SOURCE[0]}: ./funlist/a
	#                              funlist/a
	# 删除行首空格: sed 's/^[ \t]*//g'
	# 删除行尾空格: sed 's/[ \t]*$//g'	
	
	# ./funlist/a/bc.sh  =>  funlist/a/bc.sh
	#  /funlist/a/bc.sh
	# 文件
	local File="${1:-${BASH_SOURCE[0]}}"
	[ "${File:0:1}" == "." ]  &&  File="`echo "${File}" | sed 's/^\.//g' | sed 's/^\///g'`"
	# ID(md5sum(文件路径))
	local TMP_ID="`echo -n "${File}" | md5sum | cut -d ' ' -f 1`"
		
	# 存在记录时，使用已存记录的索引	
	for key in ${!MAP_ID[@]}
	do
		if [ "${TMP_ID}" == "${MAP_ID[$key]}" ];then
			#echo "ID hit..."
			local MAP_NextIndex="${MAP_Index}"
			MAP_Index="${key}"
		fi
	done
	
	# MAP全局索引
	MAP_Index="${MAP_Index:-0}"
	# ID(md5sum(文件路径))
	MAP_ID[${MAP_Index}]="${TMP_ID}"
	# 文件列表
	MAPSET_FileList[${MAP_Index}]="${File}"
	let MAP_Index++	
	# 恢复索引
	[ "${MAP_NextIndex}" != "" ] &&  MAP_Index="${MAP_NextIndex}"
}
##### 函数测试 #####
# MAP_SET_FileList
# 执行时间: 00:08
# MAP_SET_FileList  "/funlist/a/bc1.sh"
# 执行时间: 00:04
# MAP_SET_FileList  "/funlist/a/bc2.sh"
# MAP_SET_FileList  "/funlist/a/bc3.sh"
# MAP_SET_FileList  "/funlist/a/bc4.sh"
# MAP_SET_FileList  "/funlist/a/bc5.sh"
# MAP_SET_FileList  "/funlist/a/bc6.sh"
# MAP_SET_FileList  "/funlist/a/bc7.sh"
# MAP_SET_FileList  "/funlist/a/bc8.sh"
# MAP_SET_FileList  "/funlist/a/bc9.sh"
# MAP_SET_FileList  "/funlist/a/bc10.sh"
# MAP_SET_FileList
# 执行时间: 00:43 

# ================================================== 
# 函数名称: FUN_Source
# 函数功能: 文件加载
# 函数参数:  
#     	 [$1]:   文件路径 
# 
# ================================================== 
function FUN_Source(){
	#需要加载的文件
	local SourceFile="${1:-}"
	
	#设置 映射表.文件列表
	[ -e "${SourceFile}" ] &&  MAP_SET_FileList "${SourceFile}"
	#加载文件
	if [ "${SourceFile}" != "" ];then
		# 加载模式(1:主动|0:被动<默认>)
		Sys_LoadMode="1"
		if [ -e "${SourceFile}" ];then 
			echo "[FUN_Source] ${SourceFile}"
			source "${SourceFile}"  
		else 
			echo "[FUN_Source:File not exist] ${SourceFile}"
		fi
	fi
}
##### 函数测试 #####
# FUN_Source  "/funlist/a/bc1.sh"
# FUN_Source  "/funlist/a/bc2.sh"
# FUN_Source  "/funlist/a/bc3.sh"
# FUN_Source  "/funlist/a/bc4.sh"
# FUN_Source  "/funlist/a/bc5.sh"
# FUN_Source  "/funlist/a/bc6.sh"
# FUN_Source  "/funlist/a/bc7.sh"
# FUN_Source  "/funlist/a/bc8.sh"
# FUN_Source  "/funlist/a/bc9.sh"
# FUN_Source  "/funlist/a/bc10.sh"

# ================================================== 
# 函数名称: MAP_SET 
# 函数功能: 映射表:设置 
# 函数参数: 
#     	 [$1]:   更多数据(1:是|0:否<默认>) 
#
# 变量列表:
#         ${MAP_FileName[0]} : 文件名称(bc.sh)
#     ${MAP_AbsolutePath[0]} : 绝对路径(/mnt/.../funlist/a)
#     ${MAP_RelativePath[0]} : 相对路径(funlist/a)
#          ${MAP_FunList[0]} : 函数列表(,号分隔)
#      ${MAP_FunList_Raw[0]} : 函数列表(原生,包含换行符)
#     ${MAP_FunList_Array_0} : 函数列表(数组)
#                              #eval echo "\${MAP_FunList_Array_${MAP_Index}[0]}"  
# 返回值: 
# 		$?: 获取调用结果(调用后立即使用) 
# 		    0: 执行成功 
# 		    1: 执行失败 
# 
# ================================================== 
function MAP_SET(){ 
	#更多数据(1:是|0:否<默认>)
	local isMore="${1:-0}"
	
	# 设置数据	
	for key in ${!MAPSET_FileList[@]}
	do
		# 文件名称(bc.sh)
		[ "${MAP_FileName[${key}]}" == "" ] && MAP_FileName[${key}]="${MAPSET_FileList[$key]##*/}"
		# 绝对路径(/mnt/.../funlist/a)
		[ "${MAP_AbsolutePath[${key}]}" == "" ] && MAP_AbsolutePath[${key}]="$(cd $(dirname ${MAPSET_FileList[$key]}); pwd)"
		# 相对路径(funlist/a) 
		[ "${MAP_RelativePath[${key}]}" == "" ] && MAP_RelativePath[${key}]="`dirname ${MAPSET_FileList[$key]}`"
		if [ "${isMore}" == "1" ]; then
			# 函数列表(原生,包含换行符)
			MAP_FunList_Raw[${key}]="`cat ${MAPSET_FileList[$key]} | grep "^function.*" | sed 's/function//g' | sed 's/()//g' | sed 's/{//g' | sed 's/^[ \t]*//g' | sed 's/[ \t]*$//g'`"
			# 函数列表(数组)
			eval MAP_FunList_Array_${key}=\(`echo "${MAP_FunList_Raw[${key}]}"`\)
			# 函数列表(,号分隔)	
			for i in `eval echo '${MAP_FunList_Array_'"${key}"'[@]}'`
			do
				[ "${FunList}" != "" ] &&  FunList="${FunList},${i}" || FunList="${i}"
			done
			MAP_FunList[${key}]="${FunList}"
			unset FunList
		else 
			# 函数列表(原生,包含换行符)
			MAP_FunList_Raw[${key}]=""
			# 函数列表(数组)
			eval MAP_FunList_Array_${key}=""
			# 函数列表(,号分隔)
			MAP_FunList[${key}]=""
		fi
		
	done

	# 清除变量
	unset FunList	
}
##### 函数测试 #####
# FUN_Source
# FUN_Source  "tmp/a/ta.sh"
# FUN_Source  "tmp/b/tb.sh"
# MAP_SET 
#
# echo "ID: ${MAP_ID[0]}"
# echo "FileName: ${MAP_FileName[0]}"
# echo "AbsolutePath: ${MAP_AbsolutePath[0]}"
# echo "MAP_RelativePath: ${MAP_RelativePath[0]}"
# echo "MAP_FunList: ${MAP_FunList[0]}"
# echo 
# echo "ID: ${MAP_ID[1]}"
# echo "FileName: ${MAP_FileName[1]}"
# echo "AbsolutePath: ${MAP_AbsolutePath[1]}"
# echo "MAP_RelativePath: ${MAP_RelativePath[1]}"
# echo "MAP_FunList: ${MAP_FunList[1]}"
# echo 
# echo "ID: ${MAP_ID[2]}"
# echo "FileName: ${MAP_FileName[2]}"
# echo "AbsolutePath: ${MAP_AbsolutePath[2]}"
# echo "MAP_RelativePath: ${MAP_RelativePath[2]}"
# echo "MAP_FunList: ${MAP_FunList[2]}"

# ================================================== 
# 函数名称: MAP_GET					  	 
# 函数功能: 映射表:获取	 
# 函数参数: 			 		 	  				 
#     	 $1: 查询字段
#     	 $2: 条件字段01(key)
#     	 $3: 条件内容01(value)
#      [$4]: 条件字段02(key)(and)     		      	 
#      [$5]: 条件内容02(value)
#  
# 可用查询字段:
#               MAP_ID : ID
#         MAP_FileName : 文件名称
#     MAP_AbsolutePath : 绝对路径(/mnt/.../funlist/a)
#     MAP_RelativePath : 相对路径(funlist/a)
#          MAP_FunList : 函数列表(,号分隔)
#      MAP_FunList_Raw : 函数列表(原生,包含换行符)
#
# 可用条件字段:
#         MAP_FileName : 文件名称
#     MAP_AbsolutePath : 绝对路径(/mnt/.../funlist/a)
#     MAP_RelativePath : 相对路径(funlist/a)
#          MAP_FunList : 函数名称
#
# 返回值:  									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败								 	
# 			 		  		 	  
# 	                       Str : 结果(取值为最后一个匹配的结果) 
# 	                 ${Result} : 结果(取值为最后一个匹配的结果) 
# 	       ${MAP_Result_Index} : 结果 索引
# 	          ${MAP_Result_ID} : 结果 ID
# 	    ${MAP_Result_FileName} : 结果 文件名称
# 	${MAP_Result_AbsolutePath} : 结果 绝对路径
# 	${MAP_Result_RelativePath} : 结果 相对路径
# 	     ${MAP_Result_FunList} : 结果 函数列表(,号分隔)
# 	  ${MAP_Result_FunListRaw} : 结果 函数列表(原生,包含换行符)			 									 	  
# ================================================== 
function MAP_GET(){
	#查询字段
	local QueryField="${1}"
	#条件字段01
	local ConditionKey_01="${2}"	
	#条件内容01
	local ConditionValue_01="${3}"
	#条件字段02
	local ConditionKey_02="${4:-}"	
	#条件内容02
	local ConditionValue_02="${5:-}"
	
	if [ "${ConditionKey_02}" != "" ];then
		# 多条件查询
		for key in ${!MAP_FileName[@]}
		do
			local c1="`eval echo "\\${${ConditionKey_01}[${key}]}" | grep -w "${ConditionValue_01}"`"						
			local c2="`eval echo "\\${${ConditionKey_02}[${key}]}" | grep -w "${ConditionValue_02}"`"						
			#c1="`echo "${c1}" | grep -w "${ConditionValue_01}"`"		
			#c2="`echo "${c2}" | grep -w "${ConditionValue_02}"`"		
			if [ "${c1}" != "" ] && [ "${c2}" != "" ];then
				eval MAP_Result="\${${QueryField}[${key}]}"
				MAP_Result_Index="${key}"
				MAP_Result_ID="${MAP_ID[${key}]}"
				MAP_Result_FileName="${MAP_FileName[${key}]}"
				MAP_Result_AbsolutePath="${MAP_AbsolutePath[${key}]}"
				MAP_Result_RelativePath="${MAP_RelativePath[${key}]}"
				MAP_Result_FunList="${MAP_FunList[${key}]}"
				MAP_Result_FunListRaw="${MAP_FunListRaw[${key}]}"
			fi 
		done 
	else
		# 单条件查询
		for key in ${!MAP_FileName[@]}
		do			
			local c1="`eval echo "\\${${ConditionKey_01}[${key}]}" | grep -w "${ConditionValue_01}"`"			
			#c1="`echo "${c1}" | grep -w "${ConditionValue_01}"`"		
			if [ "${c1}" != "" ];then
				eval MAP_Result="\${${QueryField}[${key}]}"
				MAP_Result_Index="${key}"
				MAP_Result_ID="${MAP_ID[${key}]}"
				MAP_Result_FileName="${MAP_FileName[${key}]}"
				MAP_Result_AbsolutePath="${MAP_AbsolutePath[${key}]}"
				MAP_Result_RelativePath="${MAP_RelativePath[${key}]}"
				MAP_Result_FunList="${MAP_FunList[${key}]}"
				MAP_Result_FunListRaw="${MAP_FunListRaw[${key}]}"
			fi
		done
	fi
	# 返回结果
	echo ${MAP_Result}	

	# 清除变量
	#unset MAP_Result
}
##### 函数测试 #####
# MAP_GET "MAP_RelativePath"  "MAP_FileName" "ta.sh"
# MAP_GET "MAP_RelativePath" "MAP_FunList" "MAP_SETs" "MAP_FileName" "ta.sh"
# echo MAP_RelativePath: ${MAP_Result}
##### 使用示例 ##### 
#脚本所在目录
# SPath="`MAP_GET "MAP_AbsolutePath" "MAP_FileName" "ta.sh"`"
# echo MAP_AbsolutePath: ${SPath}

# ================================================== 
# 函数名称: testENV 
# 函数功能: 测试环境是否符合脚本要求 
# 函数参数: 
# 
# 上下文变量: 
# 		 App_testON : 开关(true|false) 
#  App_testFileName : 文件名 
# 	App_testDirName : 目录名 
# 	   App_testMult : 多条件关系(and|or) 
# 返回值: 
# 		         Str : 项目实际路径(/.../funlist 或 /)
# ${RealProjectPath} : 项目实际路径(/.../funlist 或 /)
# ================================================== 
function testENV(){
	# 原理：检测当前路径下是否有指定的文件或目录
	#
	# ${FUNCNAME[0]} : 当前函数名
	# 获取符合条件的路径( /mnt/f_DockerData )
	# -d : 判断是否为目录，存在为true
	# -e : 判断是否为文件，存在为true
	# 由于！取反，实际结果: 
	# && :  任一个true，则执行循环体 (or)
	# || :  都为true，则执行循环体 (and)
	
	local ScriptDir="`MAP_GET "MAP_AbsolutePath" "MAP_FunList" "${FUNCNAME[0]}"`"
	cd ${ScriptDir}
	if [ "${App_testMult}" == "and" ];then
		# 条件关系: 和(and)
		while ( [ ! -d $App_testDirName ] || [ ! -e $App_testFileName ]  )
		do				
			# 根目录，退出循环，避免死循环
			if [ `pwd` == '/' ]; then					
				break
			else
				cd ..					
			fi
		done
		RealProjectPath=`pwd`
	elif [ "${App_testMult}" == "or" ];then
		# 条件关系: 或(or)
		while ( [ ! -d $App_testDirName ] && [ ! -e $App_testFileName ]  )
		do
			# 根目录，退出循环，避免死循环
			if [ `pwd` == '/' ]; then					
				break
			else
				cd ..					
			fi
		done
		RealProjectPath=`pwd`
	fi		
	cd ${ScriptDir}
	echo ${RealProjectPath}
}
#testENV

# 使用环境测试
[ $App_testON == 'true' ] && testENV
#默认处理: 设置此脚本的相关信息
[ "${Sys_LoadMode}" == "0" ] &&  FUN_Source
# FUN_Source  "tmp/a/ta.sh"
# FUN_Source  "tmp/b/tb.sh"
#推荐在加载完所有文件后使用
[ "${Sys_LoadMode}" == "0" ] &&  MAP_SET 


# 脚本名称
SCRIPT_NAME=${BASH_SOURCE[0]##*/}
# 脚本所在目录
# BASH_SOURCE[0]: 存储脚本的名称，如 funlist/a/bc.sh
# 注: 只适用于bash shell，不会改变cd目录
#     SCRIPT_DIR=$(cd $(dirname $0); pwd)  #不准确# $0不同方式调用结果不同
## OK # ./XXX.sh 	  :  /mnt/f_DockerData/scripts
## OK # source XXX.sh :  /mnt/f_DockerData/scripts
## OK # bash XXX.sh	  :  /mnt/f_DockerData/scripts
## NO # sh XXX.sh	  :  Error
#SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE[0]}); pwd) #改用如下方式# 
#SCRIPT_DIR="`MAP_GET "MAP_AbsolutePath" "MAP_FileName" "${SCRIPT_NAME}"`"
# 跳转到脚本目录
[ "${App_toScriptDir}" == "1" ] && cd ${SCRIPT_DIR}

# Debug
[ "${Sys_Debug}" == 1 ] && echo RealProjectPath: $RealProjectPath
[ "${Sys_Debug}" == 1 ] && echo PWD: $(pwd)
# ----预处理--------------------------------------------#


# ----参数处理------------------------------------------------------------------------------------------#

# ----参数处理------------------------------------------------------------------------------------------#


# ----函数定义------------------------------------------------------------------------------------------#

# ================================================== 
# 函数名称: outhelp		 					  	 
# 函数功能: 帮助文档	  	  							 
# 函数参数: 			 		 	  				 
# 			 									 	 
# 返回值:  									 	  
# 		 Document	 									 	  
# ================================================== 
function outhelp()
{			
	echo
	echo "xxxxxxxx"
	echo
	echo "先引用该文件，再调用相关函数"
	echo "source ${SCRIPT_NAME}"
	echo
	echo "FunctionName  arg1  arg2  ... "
	echo "       参数列表: "
	echo "         arg1: xxxxxx。必需"
	echo "         arg2: xxxxx。可选"
	echo  	 
	echo "示例: "
	echo "FunctionName  8.0"  
		
	return 0 2>/dev/nul
	exit 0
}

# ================================================== 
# 函数名称：FontColorTest	  	 
# 函数功能：字体颜色测试				 
# 函数参数：			 		 	  				 
#     		 [$1]:  演示样式(1:横列|0:竖列<默认>) 	      	 
# 			 							 	 
# 返回值： 									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败								 	
# 			 									 	  
# ================================================== 
function FontColorTest(){
	# 演示样式(1:横列|0:竖列) 	 
	FontColorTest_Style="${1:-0}"
	
	FontColorTest_L=1
	[ "${SYS_Lang}" == "cn" ] && FontColorTest_L=1  || FontColorTest_L=0
	
	if [ "${FontColorTest_L}" == "1" ];then
		if [ "${FontColorTest_Style}" == "1" ];then
			echo '字体颜色演示:'
			echo -e "\033[1;30m黑色(30)\033[0m \033[1;31m红色(31)\033[0m \033[1;32m绿色(32)\033[0m \033[1;33m黄色(33)\033[0m \033[1;34m蓝色(34)\033[0m \033[1;35m紫红色(35)\033[0m \033[1;36m青蓝色(36)\033[0m \033[1;37m白色(37)\033[0m"
		fi	
		if [ "${FontColorTest_Style}" == "0" ];then 
			echo '字体颜色演示:'
			echo -e "  黑色:30: \033[1;30m字体颜色\033[0m" 
			echo -e "  红色:31: \033[1;31m字体颜色\033[0m"  
			echo -e "  绿色:32: \033[1;32m字体颜色\033[0m"  		
			echo -e "  黄色:33: \033[1;33m字体颜色\033[0m"  		
			echo -e "  蓝色:34: \033[1;34m字体颜色\033[0m"  		
			echo -e "紫红色:35: \033[1;35m字体颜色\033[0m"  
			echo -e "青蓝色:36: \033[1;36m字体颜色\033[0m"  	
			echo -e "  白色:37: \033[1;37m字体颜色\033[0m"
		fi
	else
		if [ "${FontColorTest_Style}" == "1" ];then
			echo 'Font color demo:'
			echo -e "\033[1;30mBlack(30)\033[0m \033[1;31mRed(31)\033[0m \033[1;32mGreen(32)\033[0m \033[1;33mYellow(33)\033[0m \033[1;34mBlue(34)\033[0m \033[1;35mPurplish red(35)\033[0m \033[1;36mBluish green(36)\033[0m \033[1;37mWhite(37)\033[0m"
		fi	
		if [ "${FontColorTest_Style}" == "0" ];then 
			echo 'Font color demo:'
			echo -e "  Black:30: \033[1;30mFont color\033[0m" 
			echo -e "  Red:31: \033[1;31mFont color\033[0m"  
			echo -e "  Green:32: \033[1;32mFont color\033[0m"  		
			echo -e "  Yellow:33: \033[1;33mFont color\033[0m"  		
			echo -e "  Blue:34: \033[1;34mFont color\033[0m"  		
			echo -e "Purplish red:35: \033[1;35mFont color\033[0m"  
			echo -e "Bluish green:36: \033[1;36mFont color\033[0m"  	
			echo -e "  White:37: \033[1;37mFont color\033[0m"
		fi
	fi
	# 清除变量
	unset FontColorTest_Style	
	unset FontColorTest_L	
}
##### 函数测试 #####
#FontColorTest 1

# ================================================== 
# 函数名称：ImportImage			 					  	 
# 函数功能：导入镜像	  	  							 
# 函数参数：			 		 	  				 
#     		 $1:   镜像文件				      	 
# 			 									 	 
# 返回值： 									 	  
# 		   0: 执行成功							 	
# 		   1: 执行失败							 	
# 			 									 	  
# ================================================== 
function ImportImage()
{		
	# 参数检查
	if [ ! $1 ] ; then
	    echo "ImportImage():参数不能为空"
	    return 1
	elif [ ! -e "$1" ]  ; then
		echo "[文件不存在]$1"
	    return 1
	fi
	
	# 执行命令
	(
		[ "${App_Debug}" == 1 ] && echo [ docker load -i "$1"  ]
		# 导入镜像
		#docker load -i php_5.6-fpm.tar   
		docker load -i "$1"
	) && (	
		echo "[${LANG_Helpers_ImportImage_01:-导入镜像成功}]$1"		
	) || (
		echo "[${LANG_Helpers_ImportImage_02:-导入镜像失败}]$1"
		return 1
	)
	return 0
}
##### 函数测试 #####
#  ImportImage  "/tmp/aa/php_5.6-fpm.tar"  

# ================================================== 
# 函数名称：ExportImage			 					  	 
# 函数功能：导出镜像	  	  							 
# 函数参数：			 		 	  				 
#     		 $1:   保存路径(***/)				      	 
#     	     $2:   镜像名称:标签			      	 
# 			 									 	 
# 返回值： 									 	  
# 		   0: 执行成功							 	
# 		   1: 执行失败							 	
# 			 									 	  
# ================================================== 
function ExportImage()
{	
	# 参数检查
	if [ ! $1 ] || [ ! $2 ] ; then
	   echo "ExportImage():参数不能为空"
	   return 1	
	fi

	# 保存路径
	SaveDir="$1"
	# 镜像名称:标签
	ImageTag="$2"
	# 目标
	#Target=${SaveDir}${ImageTag//:/_}.tar
	# : => @
	Target=${ImageTag//:/@}
	# / => #
	Target=${Target//\//#}
	Target=${SaveDir}${Target}.tar
	
	## 目录不存在则创建
	if [ ! -d  "${SaveDir}" ]; then  
	  (
		[ "${App_Debug}" == 1 ] && echo [ sudo mkdir -p "${SaveDir}" ]
		# -p : 如果存在错误，根据需要生成父目录
		sudo mkdir -p "${SaveDir}"
	  ) && (
		echo "[${LANG_Helpers_ExportImage_01:-创建目录成功}]${SaveDir}"
	  ) || (
		echo "[${LANG_Helpers_ExportImage_02:-创建目录失败}]${SaveDir}"
		return 1
	  )
	fi		
	# 执行命令
	(
		[ "${App_Debug}" == 1 ] && echo [ docker save -o "${ImageTag}"   "==>"  "${Target}" ]
		# 导出镜像
		#docker save -o php_5.6-fpm.tar   php:5.6-fpm
		docker save -o ${Target}  ${ImageTag}
	) && (	
		echo "[${LANG_Helpers_ExportImage_03:-导出镜像成功}]${ImageTag} ==> ${Target}"
	) || (
		echo "[${LANG_Helpers_ExportImage_04:-导出镜像失败}]${ImageTag}"
		return 1
	)
	
	# 清除变量
	unset SaveDir
	unset ImageTag
	unset Target	
	
	return 0
}
##### 函数测试 #####
#  ExportImage  "/tmp/aa/"   "php:5.6-fpm"

# ================================================== 
# 函数名称：Lang_load		 					  	 
# 函数功能：语言文件加载  							 
# 函数参数：			 		 	  				 
#     		 $1:   项目(item)				      	 
#     		       "${SYS_LangDir}${item}/${item}.${SYS_Lang}"				      	 
# 			 									 	 
# 返回值： 									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败							 	
# 	
# ================================================== 
function Lang_load(){
	# 项目
	item="$1"
	# 语言文件
	Lang_load_File="${SYS_LangDir}${item}/${item}.${SYS_Lang}"
	Lang_load_File_EN="${SYS_LangDir}${item}/${item}.en"
	
	# 加载文件
	if [ -e "${Lang_load_File}" ];then
		source "${Lang_load_File}"
	else	
		[ -e "${Lang_load_File_EN}" ] && source "${Lang_load_File_EN}"
	fi	
	if [ -e "${SYS_LangDir}lang.${SYS_Lang}" ];then
		source "${SYS_LangDir}lang.${SYS_Lang}"
	else	
		[ -e "${SYS_LangDir}lang.en" ] && source "${SYS_LangDir}lang.en"
	fi
	# 清除变量
	unset item	
	unset Lang_load_File		
}
##### 函数测试 #####
# Lang_load  "Show_SysInfo"


# docker系统信息
function Show_SysInfo(){	
	# 语言文件
	Show_SysInfo_LangFile="${SYS_LangDir}Show_SysInfo/Show_SysInfo.${SYS_Lang}"
	str=""
	if [ "${SYS_Lang}" != "en" ];then	
		# 构建参数列表
		if [ -e "${Show_SysInfo_LangFile}" ];then
			# 加载文件
			source "${Show_SysInfo_LangFile}"	
			# 遍历数组		
			ArgIndex=0				
			for i in "${lang_key[@]}"
			do				
				# sed 's/A/B/g;s/C/D/g'   批量替换: A=>B	
				strA="${i}"
				strB="${lang_value[${ArgIndex}]}"			
				str=${str}'s#'${strA}'#'${strB}'#g;'
				let ArgIndex++
				unset strA
				unset strB	
			done		
		fi	
		docker info | sed "${str}"
	else 
		docker info
	fi
	# 清除变量
	unset lang_key
	unset lang_value
	unset ArgIndex
	unset str
	unset Show_SysInfo_LangFile
}
##### 函数测试 #####
#Show_SysInfo

# ================================================== 
# 函数名称：SearchPrune		 					  	 
# 函数功能：单次搜索清理							 
# 函数参数：			 		 	  				 
#     		 $1:   唯一ID			      	 
#     	   [$2]:   主数据索引			      	 
# 			 									 	 
# 返回值： 									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败								 	
# 	更改文件变量 : INFO_Searchs_Clear[${i}]=\"true\"			 	  
# 	更改环境变量 : INFO_Searchs_Clear[${i}]=\"true\"			 	  
# 	    清理文件 : ${TmpDir_Searchs_Sub}DATA_Searchs_${ID}.sh
# 	
# 备注: 
# 	 	暂未使用  
# ================================================== 
function SearchPrune(){
	# ID
	ID="$1"
	[ "${ID}" == "" ] &&  echo 'SearchPrune()：ID不能为空'  &&    return 1
	# 主数据索引
	SearchsIndex="${2:-}"
	
	if [ -e "${TmpDir_Searchs_Sub}DATA_Searchs_${ID}.sh" ];then
		# 文件存在(主数据中也存在相关数据)
		#------ 更改文件变量 ------#
		echo "#!/bin/bash">"${TmpDir_Searchs}DATA_Searchs.Prune"
		i=0
		for a in  "${INFO_Searchs_ID[@]}"
		do
			nID="${INFO_Searchs_ID[${i}]}"
			nKeyword="${INFO_Searchs_Keyword[${i}]}"
			nlimit="${INFO_Searchs_limit[${i}]}"
			nClear="${INFO_Searchs_Clear[${i}]}"
			echo "INFO_Searchs_ID[${i}]=\"${nID}\"">>"${TmpDir_Searchs}DATA_Searchs.Prune"
			echo "INFO_Searchs_Keyword[${i}]=\"${nKeyword}\"">>"${TmpDir_Searchs}DATA_Searchs.Prune"
			echo "INFO_Searchs_limit[${i}]=\"${nlimit}\"">>"${TmpDir_Searchs}DATA_Searchs.Prune" 
			if [ "${a}" == "${ID}" ];then
				# 符合条件: 当前ID
				[ "${SearchsIndex}" == "" ] && SearchsIndex="${i}" # 获取主数据索引				
				echo "INFO_Searchs_Clear[${i}]=\"true\"">>"${TmpDir_Searchs}DATA_Searchs.Prune"  #是否清除变量及其文件，清除后需要设置其为true
			else
				# 不符合条件
				echo "INFO_Searchs_Clear[${i}]=\"${nClear}\"">>"${TmpDir_Searchs}DATA_Searchs.Prune"  #是否清除变量及其文件，清除后需要设置其为true
			fi
			let i++		
		done
		rm -f "${TmpDir_Searchs}Data_Searchs.sh"
		mv -f "${TmpDir_Searchs}DATA_Searchs.Prune"  "${TmpDir_Searchs}Data_Searchs.sh"
		#------ 清理文件 ------#
		rm -rf  "${TmpDir_Searchs_Sub}DATA_Searchs_${ID}.sh"		
	else
		# 文件不存在
		i=0
		for a in  "${INFO_Searchs_ID[@]}"
		do
			if [ "${a}" == "${ID}" ];then
				# 符合条件: 当前ID
				[ "${SearchsIndex}" == "" ] && SearchsIndex="${i}" # 获取主数据索引
				break
			fi
			let i++		
		done
	fi
	#------ 更改环境变量 ------#
	[ "${SearchsIndex}" != "" ] && eval INFO_Searchs_Clear[${SearchsIndex}]=\"true\"
}
##### 函数测试 #####
# noCache
#SearchPrune 1580665685
# Cache
# SearchPrune "${SearchsID}"
# echo ----------------------------------------------
# cat "${TmpDir_Searchs}Data_Searchs.sh"
# echo
# cat "${TmpDir_Searchs}DATA_Searchs.Prune"
# echo ----------------------------------------------


# ================================================== 
# 函数名称：PruneHandle
# 函数功能：清理处理							 
# 函数参数：			 		 	  				 
#     		 $1: 项目名称
#     	   [$2]: 清理模式
#     	   [$3]: 清理所有数据(1:是|0:否<默认>)
#     	         主数据+子数据，模式2生效
# 			 									 	 
# 项目名称: 
# 		  images: 清理镜像						 	  
# 		networks: 清理网络				 	  
# 		 volumes: 清理卷					 	  
# 	  containers: <清理容器>					 	  
# 返回值： 									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败	
# 	
# 清理模式: 
# 	 	1 : 清理环境中当前项目的残余变量<默认>
# 	 	    清除并重构项目的所有缓存，包含子数据
# 	 	2 : 清理环境中当前项目的所有变量
# 	 	    只清除环境中的变量，不重构，不生成新的变量
# ================================================== 
function PruneHandle(){
	# 项目名称
	PruneHandle_Item="${1,,}"
	[ "${PruneHandle_Item}" == "" ] &&  echo 'PruneHandle(): Item 不能为空'  &&    return 1
	# 清理模式
	PruneHandle_Mode="${2:-1}"
	# 清理模式
	PruneHandle_ClearAll="${3:-0}"
		
	# 1 : 清理环境中当前项目的残余变量
	if [ "${PruneHandle_Mode}" == "1" ];then
		case "${PruneHandle_Item}" in
			"images")
				##### 清理镜像 #####
				#删除缓存相关目录及文件
				rm -rf  "${TmpDir_Images}"*
				#重构缓存相关目录
				Init_FileDir
				#刷新数据
				CacheHandle "images" "" 1 true 0
				#环境变量清理
				PruneHandle_images_i=1
				for PruneHandle_images_ID in ${INFO_Images_ID[@]}
				do
					# 不存在文件时，表示没有缓存数据。此时需要清理环境残余变量				
					if [ ! -e "${TmpDir_Images_Sub}DATA_Images_${PruneHandle_images_ID}.sh" ];then
						#清理子数据
						unset  INFO_Images_${PruneHandle_images_ID}_ID            # 镜像完整ID
						unset  INFO_Images_${PruneHandle_images_ID}_Created       # 镜像创建时间
						unset  INFO_Images_${PruneHandle_images_ID}_DockerVersion # Docker版本
						unset  INFO_Images_${PruneHandle_images_ID}_Author        # 镜像作者
						unset  INFO_Images_${PruneHandle_images_ID}_Architecture  # 镜像架构
						unset  INFO_Images_${PruneHandle_images_ID}_Os            # 镜像操作系统
						unset  INFO_Images_${PruneHandle_images_ID}_Size          # 镜像大小(字节)						  
						unset  INFO_Images_${PruneHandle_images_ID}_RepoTags      # 仓库和标签(数组)
						#清理主数据
						unset  INFO_Images_ID[${PruneHandle_images_i}]               # 镜像ID
						unset  INFO_Images_Repository[${PruneHandle_images_i}]       # 镜像仓库
						unset  INFO_Images_Tag[${PruneHandle_images_i}]              # 镜像标签
						unset  INFO_Images_CreatedSince[${PruneHandle_images_i}]     # 镜像自创建以来的时间
						unset  INFO_Images_CreatedAt[${PruneHandle_images_i}]        # 镜像创建时间
						unset  INFO_Images_Size[${PruneHandle_images_i}]             # 镜像大小
						unset  INFO_Images_Architecture[${PruneHandle_images_i}]     # 镜像架构
						unset  INFO_Images_Os[${PruneHandle_images_i}]               # 镜像操作系统	
					fi
					let PruneHandle_images_i++
				done
				unset PruneHandle_images_i
				unset PruneHandle_images_ID
				;;
			"networks")
				##### 清理网络 #####
				#删除缓存相关目录及文件
				rm -rf  "${TmpDir_Networks}"*
				#重构缓存相关目录
				Init_FileDir
				#刷新数据
				CacheHandle "networks" "" 1 true 0
				#环境变量清理
				PruneHandle_networks_i=1
				for PruneHandle_networks_ID in ${INFO_Networks_ID[@]}
				do
					# 不存在文件时，表示没有缓存数据。此时需要清理环境残余变量				
					if [ ! -e "${TmpDir_Networks_Sub}DATA_Networks_${PruneHandle_networks_ID}.sh" ];then
						#清理子数据
						unset  INFO_Networks_${PruneHandle_networks_ID}_Name          # 网络名称
						unset  INFO_Networks_${PruneHandle_networks_ID}_ID            # 网络完整ID
						unset  INFO_Networks_${PruneHandle_networks_ID}_Created       # 创建时间
						unset  INFO_Networks_${PruneHandle_networks_ID}_Scope         # 网络范围
						unset  INFO_Networks_${PruneHandle_networks_ID}_Driver        # 网络驱动
						unset  INFO_Networks_${PruneHandle_networks_ID}_EnableIPv6    # 启用IPv6
						unset  INFO_Networks_${PruneHandle_networks_ID}_Internal      # 内部网络
						unset  INFO_Networks_${PruneHandle_networks_ID}_IPAM_Driver   # IPAM驱动
						unset  INFO_Networks_${PruneHandle_networks_ID}_IPAM_Subnet   # IPAM子网
						unset  INFO_Networks_${PruneHandle_networks_ID}_IPAM_Gateway  # IPAM网关	
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_ID          # 容器完整ID
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_Name        # 容器名称
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_MacAddress  # 容器MAC
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_IPv4Address # 容器IP4
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_IPv6Address # 容器IP6
						unset  INFO_Networks_${PruneHandle_networks_ID}_Labels	              # 网络标签
						#清理主数据	
						unset  INFO_Networks_ID[${PruneHandle_networks_i}]               # 网络ID
						unset  INFO_Networks_Name[${PruneHandle_networks_i}]             # 网络名称
						unset  INFO_Networks_Driver[${PruneHandle_networks_i}]           # 网络驱动
						unset  INFO_Networks_Scope[${PruneHandle_networks_i}]            # 网络范围
						unset  INFO_Networks_IPv6[${PruneHandle_networks_i}]             # 启用IPv6
						unset  INFO_Networks_Internal[${PruneHandle_networks_i}]         # 内部网络
						unset  INFO_Networks_CreatedAt[${PruneHandle_networks_i}]        # 创建时间	
					fi
					let PruneHandle_networks_i++
				done
				unset PruneHandle_networks_i
				unset PruneHandle_networks_ID
				;;
			"volumes")
				##### 清理卷 #####
				#删除缓存相关目录及文件
				rm -rf  "${TmpDir_Volumes}"*
				#重构缓存相关目录
				Init_FileDir
				#刷新数据
				CacheHandle "volumes" "" 1 true 0
				#环境变量清理
				PruneHandle_volumes_i=1
				for PruneHandle_volumes_ID in ${INFO_Volumes_Name[@]}
				do
					# 不存在文件时，表示没有缓存数据。此时需要清理环境残余变量				
					if [ ! -e "${TmpDir_Volumes_Sub}DATA_Volumes_${PruneHandle_volumes_ID}.sh" ];then
						#清理子数据
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Name       # 卷名称
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Mountpoint # 卷挂载点 
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_CreatedAt  # 创建时间
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Scope      # 卷范围
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Driver     # 卷驱动
						#清理主数据	
						unset  INFO_Volumes_Name[${PruneHandle_volumes_i}]       # 卷名称
						unset  INFO_Volumes_Driver[${PruneHandle_volumes_i}]     # 卷驱动
						unset  INFO_Volumes_Scope[${PruneHandle_volumes_i}]      # 卷范围
						unset  INFO_Volumes_Mountpoint[${PruneHandle_volumes_i}] # 卷挂载点
						unset  INFO_Volumes_isolate[${PruneHandle_volumes_i}]    # 是否孤立(true:孤立|false:不孤立)
						unset  INFO_Volumes_CreatedAt[${PruneHandle_volumes_i}]  # 创建时间	
					fi
					let PruneHandle_volumes_i++
				done
				unset PruneHandle_volumes_i
				unset PruneHandle_volumes_ID
				;;
			"containers")
				##### <清理容器> #####
				#删除缓存相关目录及文件
				rm -rf  "${TmpDir_Containers}"*
				#重构缓存相关目录
				Init_FileDir
				#刷新数据
				CacheHandle "containers" "" 1 true  0
				#环境变量清理
				PruneHandle_containers_i=1
				for PruneHandle_containers_ID in ${INFO_Containers_ID[@]}
				do
					# 不存在文件时，表示没有缓存数据。此时需要清理环境残余变量				
					if [ ! -e "${TmpDir_Containers_Sub}DATA_Containers_${PruneHandle_containers_ID}.sh" ];then
						#清理子数据
						unset  INFO_Containers_${PruneHandle_containers_ID}_ID                            # 容器完整ID
						unset  INFO_Containers_${PruneHandle_containers_ID}_Created                       # 容器创建时间
						unset  INFO_Containers_${PruneHandle_containers_ID}_Image                         # 镜像ID
						unset  INFO_Containers_${PruneHandle_containers_ID}_Platform                      # 平台
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_Status                  # 状态(running|exited|paused)
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_Running                 # 运行中(true|false)
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_Paused                  # 暂停中(true|false)
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_StartedAt               # 开始时间
						unset  INFO_Containers_${PruneHandle_containers_ID}_HostConfig_RestartPolicy_Name # 重启策略
						unset  INFO_Containers_${PruneHandle_containers_ID}_HostConfig_Privileged         # 特权模式
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Gateway       # 网关
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_IPAddress     # IP
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_MacAddress    # MAC
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_Hostname               # 主机名
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_User                   # 用户
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_Tty                    # TTY
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_Image                  # 镜像名称
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_WorkingDir             # 工作目录
						unset  INFO_Containers_${PruneHandle_containers_ID}_Name                          # 容器名称
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_Source                   # 挂载 源目录
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_Destination              # 挂载 目标目录
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_Mode                     # 挂载 模式
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_SourceDestinationMode    # 挂载 源目录#目标目录#模式	
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Ports_ContainerPort    #容器端口 
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Ports_HostIp           # 主机IP(0.0.0.0)
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Ports_HostPort         # 主机端口
						#清理主数据	
						unset  INFO_Containers_ID[${PruneHandle_containers_i}]               # 容器ID
						unset  INFO_Containers_Image[${PruneHandle_containers_i}]            # 镜像
						unset  INFO_Containers_CreatedAt[${PruneHandle_containers_i}]        # 创建容器的时间
						unset  INFO_Containers_RunningFor[${PruneHandle_containers_i}]       # 容器启动以来的时间
						unset  INFO_Containers_Ports[${PruneHandle_containers_i}]            # 暴露的端口
						unset  INFO_Containers_Status[${PruneHandle_containers_i}]           # 容器状态
						unset  INFO_Containers_Names[${PruneHandle_containers_i}]            # 容器名称
						unset  INFO_Containers_Networks[${PruneHandle_containers_i}]         # 容器网络
						unset  INFO_Containers_Size[${PruneHandle_containers_i}]             # 容器磁盘大小
						unset  INFO_Containers_Status2[${PruneHandle_containers_i}]          # 容器状态(Run|Stop|Pause)	
					fi
					let PruneHandle_containers_i++
				done
				unset PruneHandle_containers_i
				unset PruneHandle_containers_ID		
				;;
			*)						
				echo "PruneHandle()：[未知选项]${PruneHandle_Item}"					
				return 1	
				;;
		esac
	fi
	
	# 2 : 清理环境中当前项目的所有变量
	if [ "${PruneHandle_Mode}" == "2" ];then
		case "${PruneHandle_Item}" in
			"images")
				##### 清理镜像 #####				
				#环境变量清理
				PruneHandle_images_i=1
				for PruneHandle_images_ID in ${INFO_Images_ID[@]}
				do
					if [ "${PruneHandle_ClearAll}" == "1" ];then
						#清理子数据
						unset  INFO_Images_${PruneHandle_images_ID}_ID            # 镜像完整ID
						unset  INFO_Images_${PruneHandle_images_ID}_Created       # 镜像创建时间
						unset  INFO_Images_${PruneHandle_images_ID}_DockerVersion # Docker版本
						unset  INFO_Images_${PruneHandle_images_ID}_Author        # 镜像作者
						unset  INFO_Images_${PruneHandle_images_ID}_Architecture  # 镜像架构
						unset  INFO_Images_${PruneHandle_images_ID}_Os            # 镜像操作系统
						unset  INFO_Images_${PruneHandle_images_ID}_Size          # 镜像大小(字节)						  
						unset  INFO_Images_${PruneHandle_images_ID}_RepoTags      # 仓库和标签(数组)
					fi
					#清理主数据
					unset  INFO_Images_ID[${PruneHandle_images_i}]               # 镜像ID
					unset  INFO_Images_Repository[${PruneHandle_images_i}]       # 镜像仓库
					unset  INFO_Images_Tag[${PruneHandle_images_i}]              # 镜像标签
					unset  INFO_Images_CreatedSince[${PruneHandle_images_i}]     # 镜像自创建以来的时间
					unset  INFO_Images_CreatedAt[${PruneHandle_images_i}]        # 镜像创建时间
					unset  INFO_Images_Size[${PruneHandle_images_i}]             # 镜像大小
					unset  INFO_Images_Architecture[${PruneHandle_images_i}]     # 镜像架构
					unset  INFO_Images_Os[${PruneHandle_images_i}]               # 镜像操作系统					
					let PruneHandle_images_i++
				done
				unset PruneHandle_images_i
				unset PruneHandle_images_ID
				;;
			"networks")
				##### 清理网络 #####				
				#环境变量清理
				PruneHandle_networks_i=1
				for PruneHandle_networks_ID in ${INFO_Networks_ID[@]}
				do
					if [ "${PruneHandle_ClearAll}" == "1" ];then
						#清理子数据
						unset  INFO_Networks_${PruneHandle_networks_ID}_Name          # 网络名称
						unset  INFO_Networks_${PruneHandle_networks_ID}_ID            # 网络完整ID
						unset  INFO_Networks_${PruneHandle_networks_ID}_Created       # 创建时间
						unset  INFO_Networks_${PruneHandle_networks_ID}_Scope         # 网络范围
						unset  INFO_Networks_${PruneHandle_networks_ID}_Driver        # 网络驱动
						unset  INFO_Networks_${PruneHandle_networks_ID}_EnableIPv6    # 启用IPv6
						unset  INFO_Networks_${PruneHandle_networks_ID}_Internal      # 内部网络
						unset  INFO_Networks_${PruneHandle_networks_ID}_IPAM_Driver   # IPAM驱动
						unset  INFO_Networks_${PruneHandle_networks_ID}_IPAM_Subnet   # IPAM子网
						unset  INFO_Networks_${PruneHandle_networks_ID}_IPAM_Gateway  # IPAM网关	
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_ID          # 容器完整ID
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_Name        # 容器名称
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_MacAddress  # 容器MAC
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_IPv4Address # 容器IP4
						unset  INFO_Networks_${PruneHandle_networks_ID}_Container_IPv6Address # 容器IP6
						unset  INFO_Networks_${PruneHandle_networks_ID}_Labels	              # 网络标签
					fi
					#清理主数据	
					unset  INFO_Networks_ID[${PruneHandle_networks_i}]               # 网络ID
					unset  INFO_Networks_Name[${PruneHandle_networks_i}]             # 网络名称
					unset  INFO_Networks_Driver[${PruneHandle_networks_i}]           # 网络驱动
					unset  INFO_Networks_Scope[${PruneHandle_networks_i}]            # 网络范围
					unset  INFO_Networks_IPv6[${PruneHandle_networks_i}]             # 启用IPv6
					unset  INFO_Networks_Internal[${PruneHandle_networks_i}]         # 内部网络
					unset  INFO_Networks_CreatedAt[${PruneHandle_networks_i}]        # 创建时间	
					let PruneHandle_networks_i++
				done
				unset PruneHandle_networks_i
				unset PruneHandle_networks_ID
				;;
			"volumes")
				##### 清理卷 #####
				#环境变量清理
				PruneHandle_volumes_i=1
				for PruneHandle_volumes_ID in ${INFO_Volumes_Name[@]}
				do
					if [ "${PruneHandle_ClearAll}" == "1" ];then
						#清理子数据
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Name       # 卷名称
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Mountpoint # 卷挂载点 
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_CreatedAt  # 创建时间
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Scope      # 卷范围
						unset  INFO_Volumes_${PruneHandle_volumes_ID}_Driver     # 卷驱动
					fi
					#清理主数据	
					unset  INFO_Volumes_Name[${PruneHandle_volumes_i}]       # 卷名称
					unset  INFO_Volumes_Driver[${PruneHandle_volumes_i}]     # 卷驱动
					unset  INFO_Volumes_Scope[${PruneHandle_volumes_i}]      # 卷范围
					unset  INFO_Volumes_Mountpoint[${PruneHandle_volumes_i}] # 卷挂载点
					unset  INFO_Volumes_isolate[${PruneHandle_volumes_i}]    # 是否孤立(true:孤立|false:不孤立)
					unset  INFO_Volumes_CreatedAt[${PruneHandle_volumes_i}]  # 创建时间	
					let PruneHandle_volumes_i++
				done
				unset PruneHandle_volumes_i
				unset PruneHandle_volumes_ID
				;;
			"containers")
				##### <清理容器> #####
				#环境变量清理
				PruneHandle_containers_i=1
				for PruneHandle_containers_ID in ${INFO_Containers_ID[@]}
				do
					if [ "${PruneHandle_ClearAll}" == "1" ];then
						#清理子数据
						unset  INFO_Containers_${PruneHandle_containers_ID}_ID                            # 容器完整ID
						unset  INFO_Containers_${PruneHandle_containers_ID}_Created                       # 容器创建时间
						unset  INFO_Containers_${PruneHandle_containers_ID}_Image                         # 镜像ID
						unset  INFO_Containers_${PruneHandle_containers_ID}_Platform                      # 平台
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_Status                  # 状态(running|exited|paused)
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_Running                 # 运行中(true|false)
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_Paused                  # 暂停中(true|false)
						unset  INFO_Containers_${PruneHandle_containers_ID}_State_StartedAt               # 开始时间
						unset  INFO_Containers_${PruneHandle_containers_ID}_HostConfig_RestartPolicy_Name # 重启策略
						unset  INFO_Containers_${PruneHandle_containers_ID}_HostConfig_Privileged         # 特权模式
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Gateway       # 网关
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_IPAddress     # IP
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_MacAddress    # MAC
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_Hostname               # 主机名
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_User                   # 用户
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_Tty                    # TTY
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_Image                  # 镜像名称
						unset  INFO_Containers_${PruneHandle_containers_ID}_Config_WorkingDir             # 工作目录
						unset  INFO_Containers_${PruneHandle_containers_ID}_Name                          # 容器名称
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_Source                   # 挂载 源目录
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_Destination              # 挂载 目标目录
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_Mode                     # 挂载 模式
						unset  INFO_Containers_${PruneHandle_containers_ID}_Mounts_SourceDestinationMode    # 挂载 源目录#目标目录#模式	
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Ports_ContainerPort    #容器端口 
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Ports_HostIp           # 主机IP(0.0.0.0)
						unset  INFO_Containers_${PruneHandle_containers_ID}_NetworkSettings_Ports_HostPort         # 主机端口
					fi
					#清理主数据	
					unset  INFO_Containers_ID[${PruneHandle_containers_i}]               # 容器ID
					unset  INFO_Containers_Image[${PruneHandle_containers_i}]            # 镜像
					unset  INFO_Containers_CreatedAt[${PruneHandle_containers_i}]        # 创建容器的时间
					unset  INFO_Containers_RunningFor[${PruneHandle_containers_i}]       # 容器启动以来的时间
					unset  INFO_Containers_Ports[${PruneHandle_containers_i}]            # 暴露的端口
					unset  INFO_Containers_Status[${PruneHandle_containers_i}]           # 容器状态
					unset  INFO_Containers_Names[${PruneHandle_containers_i}]            # 容器名称
					unset  INFO_Containers_Networks[${PruneHandle_containers_i}]         # 容器网络
					unset  INFO_Containers_Size[${PruneHandle_containers_i}]             # 容器磁盘大小
					unset  INFO_Containers_Status2[${PruneHandle_containers_i}]          # 容器状态(Run|Stop|Pause)
					let PruneHandle_containers_i++
				done
				unset PruneHandle_containers_i
				unset PruneHandle_containers_ID		
				;;
			*)						
				echo "PruneHandle()：[未知选项]${PruneHandle_Item}"					
				return 1	
				;;
		esac
	fi
	# 清除变量
	unset PruneHandle_Item
}
##### 函数测试 #####
#PruneHandle "images"


# ================================================== 
# 函数名称：ContainerDiff				  	 
# 函数功能：容器差异							 
# 函数参数：			 		 	  				 
#     		   $1:   容器ID			      	 
#     		 [$2]:   显示风格(0:背景|1:无背景<默认>)			      	 
# 			 									 	 
# 返回值： 									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败								 	
# 			 									 	  
# ================================================== 
function ContainerDiff(){
	# 容器ID
	ID="$1"
	[ "${ID}" == "" ] &&  echo 'ContainerDiff()：容器ID不能为空'  &&    return 1
	# 显示风格(0:背景|1:无背景<默认>)
	ShowStyle="${2:-1}"		
	 
	######## 非数组储值 ########
	# 源数据字符串
	# A 添加了文件或目录
	# D 文件或目录已删除
	# C 文件或目录已更改
	# A /run/nginx.pid
	OriginalStr_01=`docker container diff ${ID}`	
	#echo -e "\033[1;37m${LANG_Helpers_ContainerDiff_01:-当前容器}:\033[0m ${ID}"  #白字	
	[ "${ShowStyle}" == "0" ] && printf "\033[1;37;42m%-4s %-16s\033[0m\n"  "+"  "${LANG_Helpers_ContainerDiff_02:-添加了文件或目录}"    #绿底白字
	[ "${ShowStyle}" == "1" ] && printf "\033[1;32m%-4s %-16s\033[0m\n"     "+"  "${LANG_Helpers_ContainerDiff_02:-添加了文件或目录}"    #绿字
	[ "${ShowStyle}" == "0" ] && printf "\033[1;37;41m%-4s %-16s\033[0m\n"  "-"  "${LANG_Helpers_ContainerDiff_03:-文件或目录已删除}"    #红底白字
	[ "${ShowStyle}" == "1" ] && printf "\033[1;31m%-4s %-16s\033[0m\n"     "-"  "${LANG_Helpers_ContainerDiff_03:-文件或目录已删除}"    #红字
	[ "${ShowStyle}" == "0" ] && printf "\033[1;37;43m%-4s %-16s\033[0m\n"  "C"  "${LANG_Helpers_ContainerDiff_04:-文件或目录已更改}"    #黄底白字
	[ "${ShowStyle}" == "1" ] && printf "\033[1;33m%-4s %-16s\033[0m\n"     "C"  "${LANG_Helpers_ContainerDiff_04:-文件或目录已更改}"    #黄字
	echo	
	echo "${LANG_Helpers_ContainerDiff_05:-差异列表}:"	
	a=0
	IFS="${oldIFS}"
	echo "$OriginalStr_01" | while read -r line_01
	do
		#echo $a : $line_01		
		# 读入到数组
		arr=($line_01)		
		if [ "${arr[0]}" == "A" ];then
			[ "${ShowStyle}" == "0" ] && printf "\033[1;37;42m%-4s %-125s\033[0m\n"  "+"  "${arr[1]}"    #绿底白字
			[ "${ShowStyle}" == "1" ] && printf "\033[1;32m%-4s %-125s\033[0m\n"     "+"  "${arr[1]}"    #绿字
		fi
		if [ "${arr[0]}" == "D" ];then
			[ "${ShowStyle}" == "0" ] && printf "\033[1;37;41m%-4s %-125s\033[0m\n"  "-"  "${arr[1]}"    #红底白字
			[ "${ShowStyle}" == "1" ] && printf "\033[1;31m%-4s %-125s\033[0m\n"     "-"  "${arr[1]}"    #红字
		fi
		if [ "${arr[0]}" == "C" ];then
			[ "${ShowStyle}" == "0" ] && printf "\033[1;37;43m%-4s %-125s\033[0m\n"  "C"  "${arr[1]}"    #黄底白字
			[ "${ShowStyle}" == "1" ] && printf "\033[1;33m%-4s %-125s\033[0m\n"     "C"  "${arr[1]}"    #黄字
		fi		
		let a++
	done
	echo
	# [ "${ShowStyle}" == "0" ] && printf "\033[1;37;42m%-4s %-16s\033[0m\n"  "+"  "${LANG_Helpers_ContainerDiff_02:-添加了文件或目录}"    #绿底白字
	# [ "${ShowStyle}" == "1" ] && printf "\033[1;32m%-4s %-16s\033[0m\n"     "+"  "${LANG_Helpers_ContainerDiff_02:-添加了文件或目录}"    #绿字
	# [ "${ShowStyle}" == "0" ] && printf "\033[1;37;41m%-4s %-16s\033[0m\n"  "-"  "${LANG_Helpers_ContainerDiff_03:-文件或目录已删除}"    #红底白字
	# [ "${ShowStyle}" == "1" ] && printf "\033[1;31m%-4s %-16s\033[0m\n"     "-"  "${LANG_Helpers_ContainerDiff_03:-文件或目录已删除}"    #红字
	# [ "${ShowStyle}" == "0" ] && printf "\033[1;37;43m%-4s %-16s\033[0m\n"  "C"  "${LANG_Helpers_ContainerDiff_04:-文件或目录已更改}"    #黄底白字
	# [ "${ShowStyle}" == "1" ] && printf "\033[1;33m%-4s %-16s\033[0m\n"     "C"  "${LANG_Helpers_ContainerDiff_04:-文件或目录已更改}"    #黄字
	# 清除变量
	unset ShowStyle
	unset ID 
}
##### 函数测试 #####
#docker exec -it 72f91ea5b39d bash
# ContainerDiff  72f91ea5b39d
# echo
# docker container diff 72f91ea5b39d

# ================================================== 
# 函数名称：CacheHandle					  	 
# 函数功能：缓存处理
# 函数参数：			 		 	  				 
#     		 $1:   单项名称
#     		 $2:   单项ID(无s的单项需要ID)    	 
#     	   [$3]:   单项完全刷新(0:否<默认>|1:是)(无s的单项无效)
#     	   [$4]:   强制刷新(false:否<默认>|true:是)
#     	   [$5]:   清理环境变量(1:清理<默认>|0:不清理)
# 			 									 	 
# 返回值： 									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败								 	
# 
# 支持的单项名称：	
#         images : Infos_Images
#          image : Infos_Image
#     containers : Infos_Containers
#      container : Infos_Container
#       networks : Infos_Networks
#        network : Infos_Network
#        volumes : Infos_Volumes
#         volume : Infos_Volume
# ================================================== 
function CacheHandle(){
	## 注意
	## Search内建缓存机制在Infos_Searchs
	
	# 项目(转换为小写)
	Item="${1,,}"
	[ "${Item}" == "" ] &&  echo 'CacheHandle()：Item 不能为空'  &&    return 1
	# 项目ID
	Item_id="$2"
	# 项目完全刷新
	Item_FullRefresh="${3:-0}"
	# 强制刷新
	ForceRefresh="${4:-false}"
	# 清理环境变量
	PruneEnv="${5:-1}"
	
	# 刷新
	Refresh=false
	# 当前时间戳(s)
	NowTime="`date +%s`"
	
	# 设置变量
	case "${Item}" in
		"images")
				CacheFile="${TmpDir_Images}Data_Images.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Images  ${Item_FullRefresh}"
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi
				Clear_Item="images"
				[ "${Item_FullRefresh}" == "1" ] && Clear_All=1 || Clear_All=0
				;;
		"image")
				[ "${Item_id}" == "" ] &&  echo 'CacheHandle()：Item_id 不能为空'  &&    return 1
				CacheFile="${TmpDir_Images_Sub}DATA_Images_${Item_id}.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Image  ${Item_id}"
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi				
				;;			
		"containers")
				CacheFile="${TmpDir_Containers}Data_Containers.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Containers  ${Item_FullRefresh}"
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi
				Clear_Item="containers"
				[ "${Item_FullRefresh}" == "1" ] && Clear_All=1 || Clear_All=0
				;;
		"container")
				[ "${Item_id}" == "" ] &&  echo 'CacheHandle()：Item_id 不能为空'  &&    return 1
				CacheFile="${TmpDir_Containers_Sub}DATA_Containers_${Item_id}.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Container  ${Item_id}"
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi				
				;;				
		"networks")
				CacheFile="${TmpDir_Networks}Data_Networks.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Networks  ${Item_FullRefresh}"
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi
				Clear_Item="networks"
				[ "${Item_FullRefresh}" == "1" ] && Clear_All=1 || Clear_All=0				
				;;
		"network")
				[ "${Item_id}" == "" ] &&  echo 'CacheHandle()：Item_id 不能为空'  &&    return 1
				CacheFile="${TmpDir_Networks_Sub}DATA_Networks_${Item_id}.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Network  ${Item_id}"
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi				
				;;			
		"volumes")
				CacheFile="${TmpDir_Volumes}Data_Volumes.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Volumes  ${Item_FullRefresh}"				
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi
				Clear_Item="volumes"
				[ "${Item_FullRefresh}" == "1" ] && Clear_All=1 || Clear_All=0
				;;
		"volume")
				[ "${Item_id}" == "" ] &&  echo 'CacheHandle()：Item_id 不能为空'  &&    return 1
				CacheFile="${TmpDir_Volumes_Sub}DATA_Volumes_${Item_id}.sh"				
				TimeFile="${CacheFile}.time"
				CmdStr="Infos_Volume  ${Item_id}"
				if [ ! -e "${TimeFile}" ];then
					[ "${App_Debug}" == 1 ] && echo "[文件不存在]${TimeFile}"
					Refresh=true
				else
					[ "${App_Debug}" == 1 ] && echo "[文件存在]${TimeFile}"
					FileTime=`cat "${TimeFile}"`
					NowTime_FileTime="$((${NowTime}-${FileTime}))"					
					# -gt  >
					[ "${NowTime_FileTime}" -gt "${SYS_Timeout}" ] && Refresh=true
				fi				
				;;
		*)
				echo "CacheHandle()：[未知选项]${Item}"
				return 1
				;;    
	esac	
	
	# 清理环境变量
	if [ "${Clear_Item}" != "" ];then
		if [ "${PruneEnv}" == "1" ];then
			[ "${App_Debug}" == 1 ] && echo PruneHandle  "${Clear_Item}"  "2"  "${Clear_All}"
			PruneHandle  "${Clear_Item}"  "2"  "${Clear_All}"
		fi
	fi
	# 构建或加载缓存
	[ "${App_Debug}" == 1 ] && echo CmdStr: ${CmdStr}
	if [ "${ForceRefresh}" == "true" ];then
		[ "${SYS_ShowTips}" == 1 ] && echo -e "\033[1;33m${LANG_Helpers_CacheHandle_01:-强制采集数据...}\033[0m"
		${CmdStr}
	elif [ "${Refresh}" == "true" ];then
		[ "${SYS_ShowTips}" == 1 ] && echo -e "\033[1;33m${LANG_Helpers_CacheHandle_02:-采集数据...}\033[0m"
		${CmdStr}
	elif [ "${Refresh}" == "false" ];then
		[ "${SYS_ShowTips}" == 1 ] && echo -e "\033[1;33m${LANG_Helpers_CacheHandle_03:-加载缓存文件...}\033[0m"	
		# 加载文件
		source "${CacheFile}"	2>/dev/null
		# case "${Item}" in
			# "images")
					# # echo 'To this01'
					# # echo 'INFO_Images_ID[1]：'"${INFO_Images_ID[1]}"
					# if [ "${INFO_Images_ID[1]}" == "" ];then
						# #echo 'To this02'	# 故障点，无法进入此处
						# source "${CacheFile}"	2>/dev/null
					# fi	
					# ;;
			# "image")			
					# if [ "`eval echo \\${INFO_Images_${Item_id}_ID}`" == "" ];then
						# source "${CacheFile}"	2>/dev/null
					# fi	
					# ;;			
			# "containers")
					# if [ "${INFO_Containers_ID[1]}" == "" ];then
						# source "${CacheFile}"	2>/dev/null
					# fi					
					# ;;
			# "container")
					# if [ "`eval echo \\${INFO_Containers_${Item_id}_ID}`" == "" ];then
						# source "${CacheFile}"	2>/dev/null
					# fi				
					# ;;				
			# "networks")
					# if [ "${INFO_Networks_ID[1]}" == "" ];then
						# source "${CacheFile}"	2>/dev/null
					# fi				
					# ;;
			# "network")
					# if [ "`eval echo \\${INFO_Networks_${Item_id}_ID}`" == "" ];then
						# source "${CacheFile}"	2>/dev/null
					# fi				
					# ;;			
			# "volumes")
					# if [ "${INFO_Volumes_Name[1]}" == "" ];then
						# source "${CacheFile}"	2>/dev/null
					# fi				
					# ;;
			# "volume")
					# if [ "`eval echo \\${INFO_Volumes_${Item_id}_Name}`" == "" ];then
						# source "${CacheFile}"	2>/dev/null
					# fi			
					# ;;
			# *)
					# echo "CacheHandle()：[未知选项]${Item}"
					# return 1
					# ;;    
		# esac
	fi
	
	# 清除变量
	unset Item
	unset Item_id
	unset Item_FullRefresh
	unset ForceRefresh
	unset Refresh
	unset NowTime
	unset NowTime_FileTime
	unset CmdStr
	unset Clear_Item
	unset Clear_All
	unset PruneEnv
	
	return 0
}
##### 函数测试 #####
# source funlist/c.Infos.funlist
# CacheHandle Images  "" 0  
# echo ---------------------------------------------- 
# echo 'INFO_Images_ID[1]:' "${INFO_Images_ID[1]}"
# echo 'INFO_Images_Repository[1]:' "${INFO_Images_Repository[1]}"
# echo ----------------------------------------------


# ================================================== 
# 函数名称：ActionHandle				  	 
# 函数功能：动作处理
# 函数参数：			 		 	  				 
#     		 $1:   项名称
#     	     $2:   动作名称	 
#     	   [$3]:   动作目标
#     	   [$4]:   输入值
#     	 [$5-9]:   其它值(包含强制-f等选项) 
# 			 									 	 
# 返回值： 									 	  
# 		$?: 获取调用结果(调用后立即使用)							  
# 		    0: 执行成功							 	
# 		    1: 执行失败								 	
# 
# 支持的项名称和(动作名称)：	
#         images : 镜像s
#				   prune : 清理镜像
#					load : 导入镜像 
#					save : 导出镜像
#					pull : 拉取镜像	
#					list : 列表
#          image : 镜像
#					details : 镜像详情
#						del : 镜像删除
#					 modify : 镜像修改(设置镜像标签)
#					   save : 镜像导出(当前)	
#     containers : 容器s
#				   export : 导出容器
#					 list : 列表
#      container : 容器
#					details : 容器详情
#					   stop : 停止容器 
#					  start : 启动容器	
#					  pause : 暂停容器
#					unpause : 恢复容器
#					restart : 重启容器
#						del : 容器删除
#					 export : 容器导出(当前)
#					 commit : 容器提交(创建镜像)
#					   exec : 进入容器	
#					   diff : 容器差异
#       networks : 网络s
#					del : 删除网络	
#					prune : 清理网络	
#					create : 创建网络	
#					list : 列表
#        network : 网络
#					details : 网络详情	 
#						del : 网络删除	
#					connect : 网络连接(容器接入到当前网络)
#				   disconnect : 网络断开(断开容器的当前网络)
#        volumes : 卷s
#					del : 删除卷	
#					prune : 清理卷	
#					create : 创建卷	
#					list : 列表
#         volume : 卷
#					details : 卷详情
#						del : 卷删除
#        Searchs : 搜索s
#					searchlist : 搜索列表
#					search : 搜索
#					prune : 清理
#         Search : 搜索
#					details : 单项详情
#					pull : 拉取镜像
#         Others : 其它s
#					set : 设置
#          Other : 其它
# ================================================== 
function ActionHandle(){
	# 项名称
	ActionHandle_Item="${1,,}"
	# 动作名称
	ActionHandle_ActionName="${2,,}"
	# 动作目标
	ActionHandle_ActionTarget="${3}"
	# 输入值
	ActionHandle_Input="${4:-}"		
	# 其它值
	ActionHandle_Arg_01="${5:-}"
	ActionHandle_Arg_02="${6:-}"
	ActionHandle_Arg_03="${7:-}"
	ActionHandle_Arg_04="${8:-}"
	ActionHandle_Arg_05="${9:-}"
	# 状态码
	ActionHandle_Code=""

	if [ "${SYS_Test}" == "0" ];then
		case "${ActionHandle_Item}_${ActionHandle_ActionName}" in
			"images_prune")
					#清理镜像
					# docker image prune  "${option}"
					docker image prune  ${ActionHandle_Arg_01}
					ActionHandle_Code="$?"
					;;
			"images_load")
					#导入镜像
					# ImportImage  "/tmp/aa/php_5.6-fpm.tar" 
					ImportImage "${ActionHandle_Input}"
					ActionHandle_Code="$?"					
					;;
			"images_save")
					#导出镜像
					# ExportImage  "/tmp/aa/"   "php:5.6-fpm"	
					ExportImage  "${ActionHandle_Input}"  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"					
					;;
			"images_pull")
					#拉取镜像
					# docker image pull "${input}"
					docker image pull "${ActionHandle_Input}" 
					ActionHandle_Code="$?"					
					;;
			"images_list")
					#列表
					CacheHandle "images"
					Show_Images  "${SYS_Style}"
					ActionHandle_Code="$?"					
					;;
			"image_details")			
					#镜像详情
					CacheHandle "Image"  "${ActionHandle_ActionTarget}"
					Show_Image "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"
					;;			
			"image_del")			
					#镜像删除(使用 名称:标签 删除镜像)
					# docker rmi  "${option}" "Repository:Tag"					
					docker rmi  ${ActionHandle_Arg_01} "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"
					;;			
			"image_modify")			
					#镜像修改(设置镜像标签)
					# docker image tag  "${action_id}"  "${Target_Image_Tag}"
					docker image tag  "${ActionHandle_ActionTarget}"  "${ActionHandle_Input}"
					ActionHandle_Code="$?"
					;;			
			"image_save")			
					#镜像导出(当前)
					# ExportImage  "/tmp/aa/"   "php:5.6-fpm"	
					ExportImage  "${ActionHandle_Input}"  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"
					;;			
			"containers_export")
					#导出容器
					# docker container export -o "${input}${ContainerName}.tar"  "container
					docker container export -o "${ActionHandle_Input}"  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;
			"containers_list")
					#列表
					CacheHandle "containers"
					Show_Containers  "${SYS_Style}"
					ActionHandle_Code="$?"				
					;;
			"container_details")
					#容器详情
					CacheHandle "container"  "${ActionHandle_ActionTarget}"
					Show_Container  "${ActionHandle_ActionTarget}"  "${ActionHandle_Input}"
					ActionHandle_Code="$?"				
					;;				
			"container_stop")
					#停止容器
					# docker container stop   "${action_id}"
					docker container stop   "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;				
			"container_start")
					#启动容器
					# docker container start   "${action_id}"
					docker container start   "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;				
			"container_pause")
					#暂停容器
					# docker container pause   "${action_id}"
					docker container pause   "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;				
			"container_unpause")
					#恢复容器
					# docker container unpause   "${action_id}"
					docker container unpause  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;				
			"container_restart")
					#重启容器
					# docker container restart   "${action_id}"
					docker container restart   "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;				
			"container_del")
					#容器删除
					# docker container rm  "${option}"  "${action_id}"
					docker container rm  "${ActionHandle_Arg_01}"  "${ActionHandle_ActionTarget}" 
					ActionHandle_Code="$?"				
					;;				
			"container_export")
					#容器导出(当前)
					# docker container export -o "${input}${ContainerName}.tar"  "${action_id}"
					docker container export -o "${ActionHandle_Input}"  "${ActionHandle_ActionTarget}" 
					ActionHandle_Code="$?"				
					;;				
			"container_commit")
					#容器提交(创建镜像)
					# docker container commit "${Options}"  "${action_id}"  "${Repository_Tag}"
					docker container commit  ${ActionHandle_Arg_01}  "${ActionHandle_ActionTarget}"  "${ActionHandle_Input}" 
					ActionHandle_Code="$?"				
					;;				
			"container_exec")
					#进入容器
					# docker exec -it "${action_id}"  bash
					docker exec -it "${ActionHandle_ActionTarget}"  bash
					ActionHandle_Code="$?"				
					;;				
			"container_diff")
					#容器差异
					# ContainerDiff  "${action_id}"
					ContainerDiff  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;				
			"networks_del")
					#删除网络
					# docker network rm  "${NetworkNameID}"
					docker network rm  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;
			"networks_prune")
					#清理网络
					# docker network prune   "${option}"
					docker network prune   ${ActionHandle_Arg_01} 
					ActionHandle_Code="$?"				
					;;
			"networks_create")
					#创建网络
					# docker network create "${Options}"  "${NetworkName}"
					docker network create  ${ActionHandle_Arg_01}  "${ActionHandle_Input}" 
					ActionHandle_Code="$?"				
					;;
			"networks_list")
					#列表
					CacheHandle "networks"
					Show_Networks  "${SYS_Style}"
					ActionHandle_Code="$?"				
					;;
			"network_details")
					#网络详情
					CacheHandle "network"  "${ActionHandle_ActionTarget}" 
					Show_Network  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;			
			"network_del")
					#网络删除
					# docker network rm   "${action_id}"
					docker network rm   "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"				
					;;			
			"network_connect")
					#网络连接(容器接入到当前网络)
					# docker network connect "${Options}"  "${action_id}"  "${ContainerNameID}"
					docker network connect ${ActionHandle_Arg_01}  "${ActionHandle_ActionTarget}"  "${ActionHandle_Input}"
					ActionHandle_Code="$?"				
					;;			
			"network_disconnect")
					#网络断开(断开容器的当前网络)
					# docker network disconnect "${Options}"  "${action_id}"   "${ContainerNameID}"
					docker network disconnect ${ActionHandle_Arg_01}  "${ActionHandle_ActionTarget}"   "${ActionHandle_Input}"
					ActionHandle_Code="$?"				
					;;			
			"volumes_del")
					#删除卷
					# docker volume rm  "${option}"  "${VolumeNameID}"
					docker volume rm  ${ActionHandle_Arg_01}  "${ActionHandle_Input}"
					ActionHandle_Code="$?"				
					;;
			"volumes_prune")
					#清理卷
					# docker volume prune  "${option}"
					docker volume prune  ${ActionHandle_Arg_01}
					ActionHandle_Code="$?"				
					;;
			"volumes_create")
					#创建卷
					# docker volume create "${Options}"  "${VolumeName}" 
					docker volume create ${ActionHandle_Arg_01}  "${ActionHandle_Input}" 
					ActionHandle_Code="$?"				
					;;
			"volumes_list")
					#列表
					CacheHandle "volumes"
					Show_Volumes  "${SYS_Style}"
					ActionHandle_Code="$?"				
					;;
			"volume_details")
					#卷详情
					CacheHandle "volume" "${ActionHandle_ActionTarget}"
					Show_Volume  "${ActionHandle_ActionTarget}"
					ActionHandle_Code="$?"			
					;;
			"volume_del")
					#卷删除
					# docker volume rm   "${option}"   "${action_id}" 
					docker volume rm   ${ActionHandle_Arg_01}   "${ActionHandle_ActionTarget}" 
					ActionHandle_Code="$?"			
					;;
			"searchs_searchlist")
					#搜索列表
					# ${SearchsIndex} 来自 Infos_Searchs
					Show_Searchs "${SearchsIndex}" "${SYS_Style}" 
					ActionHandle_Code="$?"			
					;;
			"searchs_search")
					#搜索
					# 注：搜索需要先调用Infos_Searchs获得结果
					#     然后调用Show_Searchs显示结果列表
					#Infos_Searchs  "keyword"  isCache  limit
					# Infos_Searchs  "${input}"  "${input3}"  "${input2}"
					Infos_Searchs  "${ActionHandle_Input}"  "${ActionHandle_Arg_01}"  "${ActionHandle_Arg_02}"
					# ${SearchsIndex} 来自 Infos_Searchs
					Show_Searchs "${SearchsIndex}" "${SYS_Style}" 
					ActionHandle_Code="$?"			
					;;
			"searchs_prune")
					#搜索清理
					rm -rf  "${TmpDir_Searchs}"*
					ActionHandle_Code="$?"			
					;;
			"search_details")
					#搜索单项详情
					# ${SearchsID} 来自 Infos_Searchs
					#Show_Search  "${SearchsID}"  "${action_index}"
					Show_Search  "${ActionHandle_ActionTarget}"  "${ActionHandle_Input}"
					ActionHandle_Code="$?"			
					;;
			"search_pull")
					#拉取镜像
					docker pull  "${ActionHandle_Input}"
					ActionHandle_Code="$?"			
					;;
			"others_set")
					#设置
					echo
					ActionHandle_Code="$?"			
					;;
			*)
					echo "ActionHandle()：[未知选项]${ActionHandle_Item}_${ActionHandle_ActionName}"					
					ActionHandle_Code="1"
					;; 
		esac
	else
		echo 'Test OK'
		ActionHandle_Code="$?"
	fi
	
	# 清除变量
	unset ActionHandle_Item
	unset ActionHandle_Target
	unset ActionHandle_ActionName
	unset ActionHandle_Input_01
	unset ActionHandle_Input_02
	unset ActionHandle_Force
	unset ActionHandle_Arg_01
	unset ActionHandle_Arg_02
	unset ActionHandle_Arg_03
	
	if [ "${ActionHandle_Code}" != "0" ];then
		return 1
	else
		return 0
	fi
}

# ----函数定义------------------------------------------------------------------------------------------#

# ----函数调用------------------------------------------------------------------------------------------#
# ${1,,} : 将字符串转换为小写
# 输出帮助文档
[ "${1,,}" == '--help' ] &&  outhelp


# ----函数调用------------------------------------------------------------------------------------------#







